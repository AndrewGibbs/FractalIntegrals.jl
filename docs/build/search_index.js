var documenterSearchIndex = {"docs":
[{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"using FractalIntegrals\nusing Plots; gr()\nPlots.reset_defaults()","category":"page"},{"location":"integrals.html#Integrals-on-fractals","page":"Integrals","title":"Integrals on fractals","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"In the previous section we saw how to define a fractal measure mu supported on some fractal attractor Gamma. Equipped with this measure, we can define the integral","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"I_muf = int_Gamma f(x) mathrmdmu(x)","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"for some function f.","category":"page"},{"location":"integrals.html#Quadrature-rules","page":"Integrals","title":"Quadrature rules","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"In general, I cannot be computed exactly. We must use quadrature rules to approximate I; these consist of nodes x_j and weights w_j for j=1ldotsN such that","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"I_muf approx Q_muf=sum_j=1^N f(x_j) w_j","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"for non-fractal domains and measures which are sufficiently simple, a range of quadrature rules are available. See for example, FastGaussQuadrature or QuadGK.","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"In recent decades, quadrature rules have been developed for fractal measures mu. These have been implemented in FractalIntegrals.","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"[!NOTE] Contrary to classical quadrature rules, the nodes typically lie outside of Gamma. Therefore, it is necessary to assume that f is supported on mathrmHull(Gamma).","category":"page"},{"location":"integrals.html#Gauss-Quadrature","page":"Integrals","title":"Gauss Quadrature","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"On standard domains, Gaussian qudarature rules are the most widely used for smooth f. The classical process, which involves constructing orthogaonl polynomials and a Jacobi matrix, was generalised in [1] to fractal measures mu where ","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"mathrmsupp(mu) = Gamma subset mathbbR","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"FractalIntegrals.gauss_quadrule","category":"page"},{"location":"integrals.html#FractalIntegrals.gauss_quadrule","page":"Integrals","title":"FractalIntegrals.gauss_quadrule","text":"x, w = gauss_quadrule(μ::AbstractInvariantMeasure, n::Integer)\nx, w = gauss_quadrule(Γ::AbstractAttractor, n::Integer)\n\nReturns n Gaussian weights w ∈ ℝⁿ and nodes x ∈ ℝⁿ. Here n is the order of the Gauss rule, i.e. number of weights and nodes.\n\nThis is based on the algorithm introduced in: \"A stable Stieltjes technique for computing orthogonal polynomials     and Jacobi matrices associated with a class of singular measures\", Mantica, 1996. As in this paper, the algorithm is only defined for measures and attractors in one ambient dimension.\n\n\n\n\n\n","category":"function"},{"location":"integrals.html#Barycentre-rule","page":"Integrals","title":"Barycentre rule","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"Despite its simplicity, the Barycentre rule was introduced relatively recently in [2]. It can be interpreted as a generalisation of the midpoint rule to non-standard domains.","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"The idea behind this quadrature rule is to subdivide the fractal Gamma = mathrmsupp(mu) into self-similar subcomponents no wider than some parameter h0. A node is allocated for each subcomponent Gamma_mathbfm; this node is chosen to be the barycentre","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"int_Gamma_mathbfm x mathrmdmu(x)mu(Gamma)","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"which ensures an O(h^2) convergence rate. The reason for this is analagous to the reason that the midpoint rule converges at O(h^2), because the linear errors above and below the midpoint cancel. ","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"FractalIntegrals.barycentre_quadrule","category":"page"},{"location":"integrals.html#FractalIntegrals.barycentre_quadrule","page":"Integrals","title":"FractalIntegrals.barycentre_quadrule","text":"x, w = barycentre_quadrule(μ::AbstractInvariantMeasure, h::Real)\nx, w = barycentre_quadrule(Γ::AbstractAttractor, h::Real)\n\nSubdivides the support Γ of the measure μ into self-similar components, no bigger than diameter h, and allocates quadrature points at the barycentre of each, with weights corresponding to the respective measure of each subcomonent.\n\nIf an attractor Γ is provided, Hausdorff measure is assumed.\n\nThis is based on the method introduced in: \"Numerical quadrature for singular integrals on fractals\", A. Gibbs, D. P. Hewett, A. Moiola, 2022.\n\n\n\n\n\n","category":"function"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"# define invariant measure on Koch snowflake\nΓ = getfractal(\"koch snowflake\")\n\n# get some random probability weights\np = abs.(0.5.+randn(7)/5)\n# rescale the first weight due to larger size of central component\np[1] = p[1]*sqrt(3)\np = p/sum(p)\n\n# define the invariant measure\nμ = InvariantMeasure(Γ, p)\n\n# get barycentre rule quadrature weights and nodes\nh_bary = 0.01\nx_bary, w_bary = FractalIntegrals.barycentre_quadrule(μ, h_bary)\n\n# plot the distribution of weights over the snowflake\nplot([x_[1] for x_ in x_bary],[x_[2] for x_ in x_bary],\n    linewidth=0,\n    markersize=1,\n    markershape=:circle,\n    markerstrokewidth=0,\n    marker_z = log.(w_bary),\n    axis=false,\n    grid=false,\n    legend = false,\n    aspect_ratio=1,\n    ylim=(-0.6,0.6),\n    xlim=(-0.875,0.875),\n    size = (875, 875),\n    background=nothing)","category":"page"},{"location":"integrals.html#Chaos-game-quadrature","page":"Integrals","title":"Chaos game quadrature","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"Chaos game quadrature [3] is a non-deterministic approach, analagous to Monte Carlo rules. The algorithm takes an initial guess x_0inmathbbR^n and repeatedly applies similarities s_m at random to construct further points. Mathematically, this is:","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"mathbbP(x_j = s_m(x_j-1)) = p_mquadtextfor m=1ldotsM","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"The random process above is repeated for j=1ldotsN; the weights are simply 1N.","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"FractalIntegrals.chaos_quadrule","category":"page"},{"location":"integrals.html#FractalIntegrals.chaos_quadrule","page":"Integrals","title":"FractalIntegrals.chaos_quadrule","text":"x, w = chaos_quadrule(μ::AbstractInvariantMeasure, n::Int)\nx, w = chaos_quadrule(Γ::AbstractAttractor, n::Int)\n\nRandomly allocates quadrature nodes based on the probability weights of the invariant measure μ. Quadrature weights are uniformly 1/n\n\nIf an attractor Γ is provided, Hausdorff measure is assumed.\n\nThis is based on the method introduced in: Forte, B., Mendivil, F., Vrscay, E.: \"Chaos games for iterated function systems with grey level maps\", 1998.\n\n\n\n\n\n","category":"function"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"\n# get the chaos game points\nn_chaos = length(x_bary)\nx_chaos, w_chaos = FractalIntegrals.chaos_quadrule(μ, n_chaos)\n\n# plot the distribution of points\nplot([x_[1] for x_ in x_chaos],[x_[2] for x_ in x_chaos],\n    linewidth=0,\n    markersize=0.7,\n    markershape=:circle,\n    markerstrokewidth=0,\n    axis=false,\n    grid=false,\n    legend = false,\n    aspect_ratio=1,\n    ylim=(-0.6,0.6),\n    xlim=(-0.875,0.875),\n    size = (875, 875),\n    background=nothing)","category":"page"},{"location":"integrals.html#Tensor-product-quadrature","page":"Integrals","title":"Tensor product quadrature","text":"","category":"section"},{"location":"integrals.html#Singular-integrals","page":"Integrals","title":"Singular integrals","text":"","category":"section"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"The quadrature rules described above require some smoothness of the integrand f to be accurate. We now consider a class of singular integrals:","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"J_smu = leftbeginarraycc\n    displaystyleint_Gammaint_Gamma x-y^-s mathrmdmu(y)mathrmdmu(x) sneq0\n    displaystyleint_Gammaint_Gamma logx-y mathrmdmu(y)mathrmdmu(x) s=0\n    endarray\n    right","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"These integrals are sometimes referred to as s-energy, as they may be interpreted as a generalisation of integrals quantifying electrostatic potential energy when s=01. These s-energy integrals also arise in integral equations posed on fractals, and form a key part of our integral equation solver.","category":"page"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"FractalIntegrals.s_energy","category":"page"},{"location":"integrals.html#FractalIntegrals.s_energy","page":"Integrals","title":"FractalIntegrals.s_energy","text":"s_energy(  μ::AbstractInvariantMeasure, s::Number)\ns_energy(  μ₁::AbstractInvariantMeasure, μ₂::AbstractInvariantMeasure, s::Number)\n\nComputes the s-energy of the measure μ, or possibly of two measures (with shared support) μ₁ and μ₂. The integrand is |x-y|ˢ when s is different from zero, and log|x-y| when s=0.\n\nOptional Inputs\n\nh_quad: Uses barycentre to evaluate integrals, with this parameter\nN_quad: Uses gauss rule to evaluate integrals, with this parameter\nquadrule: Evaluates s-energy with this 3-tuple of (x-nodes, y-nodes, weights). This quadrature rule should be designed for smooth integrals.\nuse_strategy_two: When true, the algorithm subdivides the fractal so all elements are a similar size. When false, each component is subdivided the same number of times, but the sizes may vary significantly.\n\n\n\n\n\n","category":"function"},{"location":"integrals.html","page":"Integrals","title":"Integrals","text":"The algorithm, which was introduced in [4], exploits self-similarity of Gamma and scaling properties of the singular integrand. It also exploits any rotational and reflective symmetry of the measure mu, which typically only occurs when mu is the Hausdorff measure.","category":"page"},{"location":"index.html#FractalIntegrals","page":"Home","title":"FractalIntegrals","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation explains basic usage of the Julia package FractalIntegrals. This package is designed to approximate integrals and solve integral equations on fractals.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"There is no generally accepted definition of the word fractal. Here we consider self-similar sets, which can be described as the attractor of an iterated function system, consisting of a set of affine contraction maps.","category":"page"},{"location":"refs.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs.html","page":"References","title":"References","text":"G. Mantica. A stable Stieltjes technique for computing orthogonal \tpolynomials and Jacobi matrices associated with a class of \tsingular measures. Constr. Approx. 12, 509–530 (1996).\n\n\n\nA. Gibbs, D. P. Hewett and A. Moiola. Numerical evaluation of singular integrals on fractal sets. Numer. Alg. 92, 2071–2124 (2023).\n\n\n\nB. Forte, F. Mendivil and E. R. Vrscay. ``Chaos games'' for iterated function systems with grey \tlevel maps. SIAM J. Math. Anal. 29, 878–890 (1998).\n\n\n\nA. Gibbs, D. P. Hewett and B. Major. Numerical evaluation of singular integrals on non-disjoint self-similar fractal sets. Numer. Alg., doi.org/10.1007/s11075-023-01705-8 (2024).\n\n\n\n","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"using FractalIntegrals\nusing Plots; gr()\nPlots.reset_defaults()","category":"page"},{"location":"makeIFS.html#Constructing-Fractals-and-Fractal-measures","page":"Fractals","title":"Constructing Fractals and Fractal measures","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"This package focuses on self-similar fractals, which can be described by a finite set of self-similar maps. These maps are called similarities.","category":"page"},{"location":"makeIFS.html#Similarities","page":"Fractals","title":"Similarities","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Each similarity is of the form:","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"s_m(x)=rho_mA_mx + delta_mquad xinmathbbR^N","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"where rho_min(01) is the contraction factor, A_minR^Ntimes N is a rotation matrix, and deltainR^N is a translation vector. Here we call NinmathbbN the ambient dimension.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Similarity","category":"page"},{"location":"makeIFS.html#FractalIntegrals.Similarity","page":"Fractals","title":"FractalIntegrals.Similarity","text":"Similarity{N, T} <: AbstractSimilarity{N, T}\n\nConstructs a similarity, which can be used to describe geometry of self-similar fractals. N is the dimension of the ambient space, and T<:Number.\n\nMathematically, this captures the following map:\n\ns(x) = δ + ρAx x  ℝⁿ\n\nFields\n\nρ :: T: The contraction factor.\nδ :: SVector{N,T}: The translation vector.\nA :: SMatrix{N,N,T} : The rotation/reflection matrix.\nρA :: SMatrix{N,N,T} : The rotation/reflection matrix multiplied by the contraction factor.\n\nExamples\n\ns₁ = Similarity(1/3, [0,0])\ns₂ = Similarity(Float32(1/3), rand(3), [-1 0; 0 1])\n\nIn the first example above, the third argument is not given,  so it is assumed that A=I.\n\nVarious binary operations can be performed on Similarity:\n\ns₂₁ = s₁ ∘ s₂\ns₂⁻¹ = inv(s₂)\ns₁³ = s₁^3\n\nIn each of the above examples, a Similarity is returned.\n\nSimilarity can be applied as a function\n\nx = rand(2)\ny = s₁(x)\n\n\n\n\n\n","category":"type"},{"location":"makeIFS.html#Attractors","page":"Fractals","title":"Attractors","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"An iterated function system (IFS) is a set of M similaritites s_m_m=1^M, and an attractor of an iterated function system Gamma satisfies","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Gamma  = bigcup_m=1^M s_m(Gamma)","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Attractor","category":"page"},{"location":"makeIFS.html#FractalIntegrals.Attractor","page":"Fractals","title":"FractalIntegrals.Attractor","text":"Attractor{N, M, T} <: AbstractAttractor{N, M, T}\n\nAn attractor of an iterated function system (IFS). In this context, an IFS should be interpreted as a set of similarities. Mathematically, an IFS attractor is the unique bounded non-empty set satisfying\n\nΓ = ₘ sₘ(Γ)\n\nwhere sₘ are similarities, defined in the docstring Similarity. For a fuller explanation, see for e.g. this wikipedia article https://en.wikipedia.org/wiki/Iterated_function_system.\n\nParameters\n\nN is the ambient dimension of the attractor\nM is the number of similarities\nT<:Number is the numeric type\n\nFields\n\nifs::SVector{M, Similarity{N, T}}: iterated function system\ndiam::T: diamter of attractor\nd::T: Hausdorff dimension of attractor\nconnectedness::Matrix{Bool}: matrix describing connected subcomponents\nsymmetries::Vector{Similarity{N, T}}: maps in symmetry group\n\nAttractors can be constructed using a vector or tuple of similarities to represent the IFS; the diameter and Hausdorff dimension are computed automatically,  the connectedness matrix is taken to be the identity, corresponding to a disjoint attractor, and the symmetry group is assumed to be the trivial group.\n\nIf the connectedness matrix is assumed to be the identity when the attractor is non-disjoint, this will impact accuracy of calculations of singular integrals.\n\nExamples\n\ns₁ = Similarity(1/3, 0)\ns₂ = Similarity(1/3, 2/3)\ncantor_set = Attractor(s₁, s₂)\n\ncourage = Similarity(1/2, [0, 0])\nwisdom  = Similarity(1/2, [1/2, 0])\npower   = Similarity(1/2, [1/4, sqrt(3)/4])\nsierpinski_triangle = Attractor(courage, wisdom, power, connectedness = Bool(ones(3,3)))\n\nNote how the connectedness matrix for the Sierpinski triangle is all ones, because the subcomponents all touch at the corners.\n\n\n\n\n\n","category":"type"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"In general, an IFS attractor has a non-integer Hausdorff dimension. The Hausdorff dimension d satisfies","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"sum_m=1^Mrho_m^d = 1","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"The following example constructs a Cantor set and displays its dimension.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"s₁ = Similarity(1/3,0)\ns₂ = Similarity(1/3,2/3)\nΓ = Attractor(s₁, s₂)\nprint(Γ)","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"println(\"Full Hausdorff dimension of Cantor Set:\", Γ.d)","category":"page"},{"location":"makeIFS.html#Plotting-attractors","page":"Fractals","title":"Plotting attractors","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Plots.plot has a method for a Attractor type.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"plot(Γ)","category":"page"},{"location":"makeIFS.html#Presets","page":"Fractals","title":"Presets","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"You can create your own attractor from scratch, as explained above. But a range of preset attractors are available.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"getfractal","category":"page"},{"location":"makeIFS.html#FractalIntegrals.getfractal","page":"Fractals","title":"FractalIntegrals.getfractal","text":"getfractal(T::Type, fractalname::Symbol; vargs...)\ngetfractal(T::Type, fractalname::String; vargs...)\ngetfractal(fractalname; vargs...)\n\nReturns a preset fractal attractor corresponding to fractalname. This can be a sybol or a string.\n\nPresets:\n\ncantorset: Cantor Set\ncantordust: Cantor Dust\nsierpinskitriangle: Sierpinski Triangle\nvicsek: Vicsek Fractal\nkochcurve: Koch Curve\nsierpinskicarpet: Sierpinski Carpet\nheighwaydragon: Heighway Dragon\nkochsnowflake: Koch Snowflake\n\nSome of the presets will take an optional input argument. For example, the contraction factor ρ∈(0,1/2] of Cantor sets and dust.\n\nΓ = getfractal(\"cantor set\"; ρ = 1/4)\n\n\n\n\n\n","category":"function"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Γ = getfractal(\"sierpinskitriangle\")\nplot(Γ)","category":"page"},{"location":"makeIFS.html#Sub-components","page":"Fractals","title":"Sub-components","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"It is often convenient to talk about a subcomponent of a fractal Gamma which is a scaled copy of the original Gamma. This is particularly useful when meshing the fractal with fractal mesh elements. To do this, vector indexing is used, for example for mathbfm=m_1ldotsm_ell,","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Gamma_mathbfm = s_m_1circ ldots circ s_m_ell (Gamma)","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"This can be achieved by treating attractors as vectors.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"Γ₁ = Γ[1]\n𝐦 = [3,2,3,1]\nΓ₃₂₃₁ = Γ[𝐦]\nplot!(Γ₁,markersize=1)\nplot!(Γ₃₂₃₁,markersize=1.5)","category":"page"},{"location":"makeIFS.html#Measures","page":"Fractals","title":"Measures","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"We now consider a measure mu supported on a fractal attractor Gamma. This is necessary to define integrals and integral equations on Gamma. For a attractor defined with M similarities, an invariant measure mu is defined by an associated set of probabilities p_1ldotsp_M satisfying sum_m=1^M p_m =1, such that","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"mu(Gamma_mathbfm) = left(prod_i=1^ell p_m_iright)mu(Gamma)","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"InvariantMeasure","category":"page"},{"location":"makeIFS.html#FractalIntegrals.InvariantMeasure","page":"Fractals","title":"FractalIntegrals.InvariantMeasure","text":"InvariantMeasure{N, M, T, A <: AbstractAttractor{N, M, T}}\n\nA general class of measure which can be defined supported on an attractor. Defined by a 'support', which is an attractor, and a vector of probability weights, invariant measures satisfy a 'balance' condition.\n\nFields\n\nsupp: The attractor on which the measure is supported\nsuppmeasure: The measure of the support\nweights: A vector of probability weights\n\n\n\n\n\n","category":"type"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"The Hausdorff Measure mathcalH^d is a special case of an Invariant Measure, where p_m=rho_m^d for m=1ldotsM. This ensures that the mass of the measure is, in some sense, spread evenly across Gamma. A useful consequence is that if Gamma is invariant under any non-trivial rotations/reflections, then this is inherited by the Hausdorff measure.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"HausdorffMeasure","category":"page"},{"location":"makeIFS.html#FractalIntegrals.HausdorffMeasure","page":"Fractals","title":"FractalIntegrals.HausdorffMeasure","text":"HausdorffMeasure{N, M, T, A <: AbstractAttractor{N, M, T}}\n\nA special case of InvariantMeasure where the contraction factors ρm and the probability weights pm satisfy ρm^d=pm, where d is the Hausdorff dimension of the attractor.\n\n\n\n\n\n","category":"type"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"The Hausdorff measure is the most natural measure for any fractal, and is used by default throughout FractalIntegrals. Recall that from an above example, Gamma represents the Sierpinski triangle.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"# no weights specified\n𝓗ᵈ = InvariantMeasure(Γ)\nprint(typeof(𝓗ᵈ))","category":"page"},{"location":"makeIFS.html#Plotting-measures","page":"Fractals","title":"Plotting measures","text":"","category":"section"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"When plot is used on an InvariantMeasure, colouring is used to represent the distribution of mass.","category":"page"},{"location":"makeIFS.html","page":"Fractals","title":"Fractals","text":"# create random set of probabilites\n𝐩 = rand(3)\n𝐩 = 𝐩/sum(𝐩)\nμ = InvariantMeasure(Γ, 𝐩)\nplot(μ, markersize = 1)","category":"page"}]
}
